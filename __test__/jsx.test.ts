import { expect, test } from "vitest";
import { parseAsync } from "..";

test('parse jsx', async () => {
  const source = "import type { PropsWithChildren, ReactElement, ReactNode } from 'react';\nimport React, { Component } from 'react';\nimport fastCompare from 'react-fast-compare';\nimport invariant from 'invariant';\n\nimport { Context } from './Provider';\nimport type { HelmetDataType } from './HelmetData';\nimport HelmetData from './HelmetData';\nimport type { DispatcherContextProp } from './Dispatcher';\nimport Dispatcher from './Dispatcher';\nimport { without } from './utils';\nimport { TAG_NAMES, VALID_TAG_NAMES, HTML_TAG_MAP } from './constants';\nimport type { HelmetProps } from './types';\n\nexport * from './types';\n\nexport { default as HelmetData } from './HelmetData';\nexport { default as HelmetProvider } from './Provider';\n\ntype Props = { [key: string]: any };\n\nexport class Helmet extends Component<PropsWithChildren<HelmetProps>> {\n  static defaultProps = {\n    defer: true,\n    encodeSpecialCharacters: true,\n    prioritizeSeoTags: false,\n  };\n\n  shouldComponentUpdate(nextProps: HelmetProps) {\n    return !fastCompare(without(this.props, 'helmetData'), without(nextProps, 'helmetData'));\n  }\n\n  mapNestedChildrenToProps(child: ReactElement, nestedChildren: ReactNode) {\n    if (!nestedChildren) {\n      return null;\n    }\n\n    switch (child.type) {\n      case TAG_NAMES.SCRIPT:\n      case TAG_NAMES.NOSCRIPT:\n        return {\n          innerHTML: nestedChildren,\n        };\n\n      case TAG_NAMES.STYLE:\n        return {\n          cssText: nestedChildren,\n        };\n      default:\n        throw new Error(\n          `<${child.type} /> elements are self-closing and can not contain children. Refer to our API for more information.`\n        );\n    }\n  }\n\n  flattenArrayTypeChildren(\n    child: JSX.Element,\n    arrayTypeChildren: { [key: string]: JSX.Element[] },\n    newChildProps: Props,\n    nestedChildren: ReactNode\n  ) {\n    return {\n      ...arrayTypeChildren,\n      [child.type]: [\n        ...(arrayTypeChildren[child.type] || []),\n        {\n          ...newChildProps,\n          ...this.mapNestedChildrenToProps(child, nestedChildren),\n        },\n      ],\n    };\n  }\n\n  mapObjectTypeChildren(\n    child: JSX.Element,\n    newProps: Props,\n    newChildProps: Props,\n    nestedChildren: ReactNode\n  ) {\n    switch (child.type) {\n      case TAG_NAMES.TITLE:\n        return {\n          ...newProps,\n          [child.type]: nestedChildren,\n          titleAttributes: { ...newChildProps },\n        };\n\n      case TAG_NAMES.BODY:\n        return {\n          ...newProps,\n          bodyAttributes: { ...newChildProps },\n        };\n\n      case TAG_NAMES.HTML:\n        return {\n          ...newProps,\n          htmlAttributes: { ...newChildProps },\n        };\n      default:\n        return {\n          ...newProps,\n          [child.type]: { ...newChildProps },\n        };\n    }\n  }\n\n  mapArrayTypeChildrenToProps(arrayTypeChildren: { [key: string]: JSX.Element }, newProps: Props) {\n    let newFlattenedProps = { ...newProps };\n\n    Object.keys(arrayTypeChildren).forEach(arrayChildName => {\n      newFlattenedProps = {\n        ...newFlattenedProps,\n        [arrayChildName]: arrayTypeChildren[arrayChildName],\n      };\n    });\n\n    return newFlattenedProps;\n  }\n\n  warnOnInvalidChildren(child: JSX.Element, nestedChildren: ReactNode) {\n    invariant(\n      VALID_TAG_NAMES.some(name => child.type === name),\n      typeof child.type === 'function'\n        ? `You may be attempting to nest <Helmet> components within each other, which is not allowed. Refer to our API for more information.`\n        : `Only elements types ${VALID_TAG_NAMES.join(\n            ', '\n          )} are allowed. Helmet does not support rendering <${\n            child.type\n          }> elements. Refer to our API for more information.`\n    );\n\n    invariant(\n      !nestedChildren ||\n        typeof nestedChildren === 'string' ||\n        (Array.isArray(nestedChildren) &&\n          !nestedChildren.some(nestedChild => typeof nestedChild !== 'string')),\n      `Helmet expects a string as a child of <${child.type}>. Did you forget to wrap your children in braces? ( <${child.type}>{\\`\\`}</${child.type}> ) Refer to our API for more information.`\n    );\n\n    return true;\n  }\n\n  mapChildrenToProps(children: ReactNode, newProps: Props) {\n    let arrayTypeChildren = {};\n\n    React.Children.forEach(children as JSX.Element, (child: ReactElement) => {\n      if (!child || !child.props) {\n        return;\n      }\n\n      const { children: nestedChildren, ...childProps } = child.props;\n      // convert React props to HTML attributes\n      const newChildProps = Object.keys(childProps).reduce((obj: Props, key) => {\n        obj[HTML_TAG_MAP[key] || key] = childProps[key];\n        return obj;\n      }, {});\n\n      let { type } = child;\n      if (typeof type === 'symbol') {\n        type = (type as 'symbol').toString();\n      } else {\n        this.warnOnInvalidChildren(child, nestedChildren);\n      }\n\n      switch (type) {\n        case TAG_NAMES.FRAGMENT:\n          newProps = this.mapChildrenToProps(nestedChildren, newProps);\n          break;\n\n        case TAG_NAMES.LINK:\n        case TAG_NAMES.META:\n        case TAG_NAMES.NOSCRIPT:\n        case TAG_NAMES.SCRIPT:\n        case TAG_NAMES.STYLE:\n          arrayTypeChildren = this.flattenArrayTypeChildren(\n            child,\n            arrayTypeChildren,\n            newChildProps,\n            nestedChildren\n          );\n          break;\n\n        default:\n          newProps = this.mapObjectTypeChildren(child, newProps, newChildProps, nestedChildren);\n          break;\n      }\n    });\n\n    return this.mapArrayTypeChildrenToProps(arrayTypeChildren, newProps);\n  }\n\n  render() {\n    const { children, ...props } = this.props;\n    let newProps = { ...props };\n    let { helmetData } = props;\n\n    if (children) {\n      newProps = this.mapChildrenToProps(children, newProps);\n    }\n\n    if (helmetData && !(helmetData instanceof HelmetData)) {\n      const data = helmetData as HelmetDataType;\n      helmetData = new HelmetData(data.context, true);\n      delete newProps.helmetData;\n    }\n\n    return helmetData ? (\n      <Dispatcher {...newProps} context={helmetData.value} />\n    ) : (\n      <Context.Consumer>\n        {context => <Dispatcher {...newProps} context={context as DispatcherContextProp} />}\n      </Context.Consumer>\n    );\n  }\n}";
  const output = await parseAsync(source, 'Helmet.tsx');

  expect(output).toEqual({
    imports: [
      {
        n: "react",
        s: 65,
        e: 70,
        ss: 0,
        se: 71,
        d: -1,
        a: -1,
      },
      {
        n: "react",
        s: 107,
        e: 112,
        ss: 73,
        se: 113,
        d: -1,
        a: -1,
      },
      {
        n: "react-fast-compare",
        s: 140,
        e: 158,
        ss: 115,
        se: 159,
        d: -1,
        a: -1,
      },
      {
        n: "invariant",
        s: 184,
        e: 193,
        ss: 161,
        se: 194,
        d: -1,
        a: -1,
      },
      {
        n: "./Provider",
        s: 222,
        e: 232,
        ss: 197,
        se: 233,
        d: -1,
        a: -1,
      },
      {
        n: "./HelmetData",
        s: 272,
        e: 284,
        ss: 235,
        se: 285,
        d: -1,
        a: -1,
      },
      {
        n: "./HelmetData",
        s: 311,
        e: 323,
        ss: 287,
        se: 324,
        d: -1,
        a: -1,
      },
      {
        n: "./Dispatcher",
        s: 370,
        e: 382,
        ss: 326,
        se: 383,
        d: -1,
        a: -1,
      },
      {
        n: "./Dispatcher",
        s: 409,
        e: 421,
        ss: 385,
        se: 422,
        d: -1,
        a: -1,
      },
      {
        n: "./utils",
        s: 449,
        e: 456,
        ss: 424,
        se: 457,
        d: -1,
        a: -1,
      },
      {
        n: "./constants",
        s: 517,
        e: 528,
        ss: 459,
        se: 529,
        d: -1,
        a: -1,
      },
      {
        n: "./types",
        s: 565,
        e: 572,
        ss: 531,
        se: 573,
        d: -1,
        a: -1,
      },
      {
        n: "./types",
        s: 591,
        e: 598,
        ss: 576,
        se: 599,
        d: -1,
        a: -1,
      },
      {
        n: "./HelmetData",
        s: 641,
        e: 653,
        ss: 602,
        se: 654,
        d: -1,
        a: -1,
      },
      {
        n: "./Provider",
        s: 699,
        e: 709,
        ss: 656,
        se: 710,
        d: -1,
        a: -1,
      },
    ],
    exports: [
      {
        s: 622,
        e: 632,
        ls: -1,
        le: -1,
        n: "HelmetData",
      },
      {
        s: 676,
        e: 690,
        ls: -1,
        le: -1,
        n: "HelmetProvider",
      },
      {
        s: 764,
        e: 770,
        ls: 764,
        le: 770,
        n: "Helmet",
        ln: "Helmet",
      },
    ],
    facade: false,
    hasModuleSyntax: true,
  });
});